

# 1.自我介绍

```
	面试官你好，我叫贺宏伟，来自山西大同，毕业山东科技大学，目前从事Web前端开发已有两年，主要使用Vue技术栈以及一些主流的第三方UI开发框架进行开发 ，能够独立开发一些核心功能，有良好的代码书写规范和封装意识，同时具有团队协作能力和较强的自我学习能力，可以快速适应环境。
	
	目前呢，是任职过两份工作，第一份工作是在济南市退役军人事务局，上一份工作是在山东远华节能新材料有限公司，当时做的一个项目是 玻璃人智能信息管理系统，开发原因主要是因为玻璃制品行业粗放式管理和未来管理迭代优化，也是为了更方便的管理公司，我呢主要负责页面开发，接口联调页面渲染，组件功能实现。
		
	工作之余，我也会持续关注业界动态并尽可能抽出时间去看一些博客（例如CSND、掘金、简书、博客园）或者是个人网站，让自己对已有技术有更深层次的理解，学习一些前沿技术，提升自己的同时跟进技术迭代。
	
	以上大概是我的基本情况，感谢您的聆听。
```

# 2.项目

### 	1.项目介绍

```
	在这家公司开发的系统叫玻璃人智能信息管理系统，
	
	开发这个系统主要是因为玻璃制品行业粗放式管理缺陷日益显露和未来管理的不断迭代优化，使用的人是本公司的 员工啊，财务啊包括领导。
	
	系统是利用vue-cli脚手架搭建和模块化开发和这个element-ui实现页面布局，模块我主要负责的是采购管理模块，对生产线设备（一些大型设备比如切割机、双磨机、钢化炉），玻璃原片和一些机械工具（角磨机、热熔机）信息的在右侧展示的一个功能，还有就是公司采购商品，在中间部分，包括这些设备(规格、厂家、生产日期)玻璃原片(尺寸、厚度、色泽品质的)和机械工具的一个添加订单功能。
	
	还有订单管理模块的开发包括客户下单入库的一个功能，（对玻璃类型、厚度、数量、加工类型啊）的订单查询、编辑和添加功能，联调接口对数据的增删改查，封装公共组件，以及页面内各个组件功能的实现。
```

### 	2.项目模块

```
该系统包括首页中心、采购管理、仓库管理、订单管理、财务管理、客户中心、售后服务、 系统设置八大模块。	
```

### 	3.人员配置

```
需求经理1人、项目组长1人、前端3人、后端5人、UI设计1人、测试2人
```

### 	4.项目亮点

```
1.首页中心使用Echarts图片可视化插件,以丰富的图表的形式展现数据，充分满足多样化的可视化需求
2.搜索框获取焦点后，下拉面板自动显示历史搜索记录,将最近15次搜索内容保存到本地存储,方便用户下次搜索 
3.在搜索过程中，200毫秒以内，用户在输入搜索关键词进行触发，期间再次输入内容，则会重新计时(防抖)
4.客户中心模块可根据成交金额按比例获取积分，客户可以通过积分兑换礼品或优惠券，并且可根据近期客户提交订单金额排名提供轮播内容	
```

### 	4.权限登录



Ø 用户进行登录，附带用户名和密码传到后端，后端进行用户鉴权，通过jwt技术生成token，并且返回给前端

Ø 前端保存token到cookie中，添加到token到http header中。之后所有请求都携带token

Ø 之后后端直接对token进行校验，解析token获得用户名并查询用户信息，返回前端用户信息和权限列表

Ø 前端获得用户信息与权限列表，校验通过重定向到首页并且前端根据用户的权限列表动态生成左侧菜单





Ø 权限管理：通过判断token来进行权限验证---访问路由时：从cookie中获取token，若存在，将根据用户角色生成动态路由，然后访问路由，生成对应的页面组件；若不存在，则会判断路由是否在白名单中，如果在白名单中将直接访问，否则说明该路由需要登录才能访问，此时会将路由生成一个 redirect 参数传入 login 组件，实际访问的路由为：/login?redirect=/xxx



Ø 退出：基于token 的方式实现退出比较简单，只需要销毁本地的 token 即可。这样，后续的请求就不会携带token ，必须重新登录生成一个新的 token 之后才可以访问页面



权限管理：通过判断token来进行权限验证----- 访问路由时会从cookie中获取token，若存在，将根据用户角色生成动态路由，然后访问路由，生成对应的页面组件；  若不存在，则会判断路由是否在白名单中，如果在白名单中将直接访问，否则说明该路由需要登录才能访问，此时会将路由生成一个 redirect 参数传入login 组件，实际访问的路由为：/login?redirect=/xxx 通过对token身份的认证来实现路由权限的控制，只有超级管理员才能参与对其他成员权限的配置，修改该用户在后端权限对应的字段值来实现页面权限的管理。
    退出：基于 token 的方式实现退出比较简单，只需要销毁本地的 token 即可。这样，后续的请求就不会携带token，必须重新登录生成一个新的token 之后才可以访问页面。







```
  判断登录
     		没有登录
        			先判断有没有白名单中
          			在白名单 直接放行  next() ['登陆页，找回密码 首页/']
          			没有  next('/login')
     		已经登录
               判断/login  
                 是login  直接重定向/首页
                 不是login  比如/user
                      发送请求  获取用户信息  主要获取角色信息
                      动态路由制作【动态菜单放入vuex】
```













登录：

利用token来鉴权用户信息并实现登录 ---用户登录后，将

传到后端，   生成token，后端便对token进行校验，解析token的信息，识别该角色的身份，通过后端字段的联表来判断该角色具备的权限路由，最后将结果返回给前端，从而实现登录。

权限管理：

通过判断token来进行权限验证---访问路由时会从cookie中获取token，若访问路由时：从cookie中获取token，若存在，将根据后端传回来的权限路由列表生成动态路由，然后访问路由，生成对应的页面组件；若不存在，则会判断路由是否在白名单中，如果在白名单中将直接访问，



因为react中没有路由守卫这个钩子，我在项目的时候自己封装了一个，通过工具类request中添加监听路由变化事件，通过history来监听，每次响应拦截的时候，把白名单定义成一个数组，判断后端返回的权限中有没有白名单中的路由，没有的话说明该路由需要登录才能访问，此时会将路由 通过redirect重定向到登录页面



 退出：退出的话简单来说就是销毁本地的token

  我分成超级管理员和区域管理，以及区域编辑，超级管理员负责的主要有统一管理区域管理的一些权限 以及处理一些区域管理发送过来的考勤、采购请求啊 ，区域管理是管理区域编辑，



因为我这个后台主要是对公司的一些自研产品上架，以及后台显示状态，和库存，区域编辑主要负责的就是商品的上架和下架，提交审核给区域管理，区域管理进行审核，

### 4.项目难点

 		**1.iPhone7用for...in 遍历数组失效**

```
问题描述：最初学习使用js时，觉得`for...in`遍历比`for循环`简洁，后期在用户反馈后发现iPhone7不支持用for...in遍历数组

解决方式： 改为`for循环`遍历
```

​		**2.audio 和 video 在 ios 和 andriod 中自动播放**

```
出于优化用户体验，苹果系统和安卓系统通常都会禁止自动播放和禁止页面加载时使用 JS 触发播放，

必须由用户主动点击页面才可以触发播放。通过给页面根元素加touchstart的监听事件实现触发播放
```

​		**3.样式上没有匹配度很高的**

# 3.html、css面试题

### 1.h5新特性

H5新特性有：

```
语义标签、增强型表单、Canvas绘图、地理定位、SVG绘图、拖放API、WebWorker、WebStorage、WebSocket
```

- 语义化标签    header，footer，nav，section，article，aside等

- 媒体标签		audio，video 

- 功能性标签     svg绘图，canvas绘图

-  智能表单

    				一些input的type类型（：email、url、range、number、mouth、time、week、date、search、color等），和新的input属性（placeholder、required、autofocus、multiple、form等）

- 本地存储      localstorage和sessionstorage

-  api               websocket, fetch(浏览器自带的数据请求方式)和requestAnimationFrame（动画定时器）等等

- 新事件          onresize, ondrag, onscroll, onmousewheel, onerror, onplay, onpause等

### 2.重绘和回流，两者区别

回流：

```
当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。
width
height
padding
border
margin
position
top
left
bottom
right
float
clear
text-align
vertical-align
line-height
font-weight
font-size
font-family
overflow
white-space
```

重绘：

```
当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，则就称为重绘。
color
border-style
border-radius
text-decoration
box-shadow
background
两者区别：
回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流
当页面布局和几何属性改变时就需要回流
```

### 3.CSS 选择符

```
1.id选择器（#id）
2.类选择器（.class）
3.标签选择器（div，h1，p）
4.相邻选择器（h1 + p）
5.子选择器（ul > li）
6.后代选择器（li a）
7.通配符选择器（ * ）
8.属性选择器（a[title]）
9.伪类选择器（a:hover，li:nth-child）
```

### **4.优先级算法如何计算**

```
1.优先级就近原则，同权重情况下样式定义最近者为准；
2.载入样式以最后载入的定位为准；
3.!important > id > class > tag；
4.important 比 内联优先级高，但内联比id要高；

1、第一等：代表内联样式，如: style=””，权值为1000。
2、第二等：代表ID选择器，如：#content，权值为0100。
3、第三等：代表类，伪类和属性选择器，如.content，权值为0010。
4、第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。
5、通配符、子选择器、相邻选择器等的。如*、>、+,权值为0000。
6、继承的样式没有权值。
```

### 5. CSS3新特性

```
word-wrap 文字换行
text-overflow 超过指定容器的边界时如何显示
text-decoration 文字渲染
text-shadow文字阴影
gradient渐变效果
transition过渡效果 transition-duration：过渡的持续时间
transform拉伸，压缩，旋转，偏移等变换
animation动画
```

### 6.简述flex布局【重要】

```
flex弹性布局，可以简便、完整、响应式地实现各种页面布局, 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）

flex-direction：决定主轴的方向
    row（默认值）：主轴为水平方向，起点在左端。
    row-reverse：主轴为水平方向，起点在右端。
    column：主轴为垂直方向，起点在上沿。
    column-reverse：主轴为垂直方向，起点在下沿。
    
justify-content：主轴对齐方式
    flex-start（默认值）：左对齐
    flex-end：右对齐
    center： 居中
    space-between：两端对齐，项目之间的间隔都相等。
    space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
    
align-items：侧轴对齐方式
    flex-start：交叉轴的起点对齐。
    flex-end：交叉轴的终点对齐。
    center：交叉轴的中点对齐。
    baseline: 项目的第一行文字的基线对齐。
    stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
    
flex-wrap：换行
    nowrap（默认）：不换行。
    wrap：换行，第一行在上方。
    wrap-reverse：换行，第一行在下方。
	flex-flow：flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。
```

### 7.css 隐藏元素方法

css隐藏元素方法

```
1.display:none
2.Jquery：show(),hide(),toggle()方法就是通过改变display的值来实现变化效果的。 
3.visibility:hidden：
和display:none的区别在于，元素在页面消失后，占据的空间依旧会保留着，但是display:none不会，所以它只会导致浏览器重绘而不会回流，因此，visibility:hidden适用于那些元素隐藏后不希望页面布局发生变化的场景；
4.opacity:0  (透明度，元素本身不会隐藏，会引起重绘)
5.overflow:hidden
6.position: absolute： 把元素脱离文档流移出视觉区域，既不会影响布局，又能让元素保持可以操作。应用该属性后，主要就是通过控制方向（top,left,right,bottom），达到一定的值，离开当前页面。
clip-path（不常用）
```

### 8.BFC是什么？应用？

```
是一个独立的渲染区域，通俗点BFC就是页面上的一个隔离的独立容器，容器里面的元素布局不受外界影响，同时也不会影响到外面的元素。
那么我们可以通过CSS为元素设置一些属性，来触发BFC,常用的方式有：
Float值不为none
Postion值不为relative和static
Overflow值为auto scroll和hidden
display值为inline-block
BFC用途：
1、防止margin重叠2、清楚内部浮动3、消除文本环绕做出自适应两栏布局
```

### 9. clearfix 清除浮动的方法

浮动为该元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。

清除浮动的方法：

```javascript
1.父元素设置 overflow：hidden
优点：不存在结构和语义化问题，代码量极少 
缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素；overflow:hidden会导致中键失效。 

2.添加额外标签
  在浮动元素末尾添加一个空的标签，<div style="clear:both"></div>
优点：通俗易懂，容易掌握 
缺点：可以想象通过此方法，会添加多少无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦。 

3.使用:after 伪元素 
需要注意的是 :after是伪元素（Pseudo-Element），不是伪类（某些CSS手册里面称之为“伪对象”），很多清除浮动大全之类的文章都称之为伪类，不过csser要严谨一点，这是一种态度。由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 
.clearfix:after {content:" "; display:block; visibility:hidden; clear:both; } 
.clearfix { *zoom:1; }
优点：结构和语义化完全正确,代码量居中 
缺点：复用方式不当会造成代码量增加 




4.使用 br标签和其自身的 html属性 
<br clear="all" /> 
优点：比空标签方式语义稍强，代码量较少 
缺点：同样有违结构与表现的分离，不推荐使用 

5.父元素设置 overflow：auto 属性。同样IE6需要触发hasLayout，演示和3差不多 
优点：不存在结构和语义化问题，代码量极少 
缺点：多个嵌套后，firefox某些情况会造成内容全选；IE中 mouseover 造成宽度改变时会出现最外层模块有滚动条等，firefox早期版本会无故产生focus等。

```

### 10.盒子水平垂直居中【重要】

```
①弹性盒模型：display:flex;（常用方法,推荐）
    justify-content:conter;
    align-itens:center;
⑤定位：（常用方法,推荐）
    position:absolute;
    position:relative;
    left:0;
    top:0;
    right:0;
    bottom:0;
    margin:auto;
③用transform的属性translate平移，不仅能实现绝对居中同样的效果，也支持联合可变高度方式使用。
    使用top:50%; left:50%;
    transform：translate(50%，50%):分别向左向上移动自身长宽的50%，使其位于中心。
     
display:table-cell;
外边距：margin-left:值;
    margin-top:值;
margin:auto;（不兼容低版本的IE浏览器）
用calc计算
```

### 11.rem和em的区别  

```
rem和em都是相对单位，主要参考的标签不同：

rem是相对于根字号，即相对于<html>标签的font-size实现的，浏览器默认字号是font-size:16px

em是相对于父元素标签的字号，和百分比%类似，%也是相对于父级的，只不过是%相对于父级宽度的，而em相对于父级字号的
```

### 12.link标签和import标签的区别

```
link属于html，而@import属于css
页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。
link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。
link方式样式的权重高于@import的。
```

### 13. Css盒模型的理解

```
当对⼀个⽂档进⾏布局的时候，浏览器的渲染引擎会将所有元素表示为⼀个个矩形的盒⼦。CSS 决定这些盒⼦的⼤⼩、位置以及属性（例如颜⾊、背 

景、边框尺⼨…     

盒模型由content（内容）、padding（内边距）、border（边框）、margin（外边距）组成。

⽽IE怪异盒模型width的宽度并不是content的宽度，⽽是border + padding + content的宽度值 

元素占据的宽度 = margin+ width 
```



# 4.js面试题

### 1.JS数据类型

```
，1基本数据类型:string，number，Boolean，null，undefined，(ES6新增symbol);
2引用数据类型object(Object,Array),function
```

### 2.JS判断数据类型的方法

```
typeof检测基本数据类型
	typeof null的值为Object，无法分辨是null还是Object
instanceof检测引用数据类型
	只能判断对象是否存在于目标对象的原型链上
Object.prototype.toString.call()
	一种最好的基本类型检测方式 Object.prototype.toString.call() ;
constructor
```

### 3.null和undefined区别

```
Undefined，有值未定义
类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。
用法：
	变量被声明了，但没有赋值时，就等于undefined。
	调用函数时，应该提供的参数没有提供，该参数等于undefined。
	对象没有赋值的属性，该属性的值为undefined。
	函数没有返回值时，默认返回undefined。
Null，没有值
类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。
用法：
	作为函数的参数，表示该函数的参数不是对象。
	作为对象原型链的终点。
```

### 4.JS作用域的理解

```
JS中的作用域分为两种：全局作用域和函数作用域。
函数作用域中定义的变量，只能在函数中调用，外界无法访问。没有块级作用域导致了if或for这样的逻辑语句中定义的变量可以被外界访问，因此ES6中新增了let和const命令来进行块级作用域的声明。
```

### 5.call,apply和bind区别

```
答：call,apply,bind主要作用都是改变this指向的，但使用上略有区别，说一下区别:
   call和apply的主要区别是在传递参数上不同，call后面传递的参数是以逗号的形式分开的，apply传递的参数是数组形式
  bind返回的是一个函数形式，如果要执行，则后面要再加一个小括号,需要再次调用 例如：bind(obj,参数1,参数2,)(),bind只能以逗号分隔形式，不能是数组形式

call也做判断数据类型
	//Object.prototype.toString.call(a) == "[object String]" //true
apply经常跟数组有关，比如借助数学对象实现数组的最大值和最小值
    // console.log(Math.max(12, 444, 4, 55, 666, 1)); //666
    // let arr = [12, 444, 4, 55, 666, 1];
    // console.log(Math.max(arr)); //NaN(该方法只能依次传入)
    // console.log(Math.max.apply(null, arr)); //666(第一个参数随便写)
bind比如改变定时器内部的this指向
```

### 6.this指向

```
		1.普通函数，定时器，立即执行 
		   this -> window
		2.obj.fun1()
		  this -> obj
		3. var obj = new Object()  
		 this -> obj  
		4. <button onclick="fun3(this)">点击</button>
		this -> button[绑定的对象] 成功
		5.fun3.call({name:'liujie'})
		this -> {name:'liujie'}
		6.es6 箭头函数的this 继承外层函数调用的 this
```

### 7.深拷贝和浅拷贝

```
深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。

浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。
深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。


浅拷贝的方法：
1.Object.assign
    var obj1 = {a: 1, b: 2};
    var obj2 = Object.assign({}, obj1);
2.扩展运算符
    var obj1 = { a:1，b:2}
    var obj2={ ...obj1 }
浅拷贝实现原理：
        function shallowCopy(obj) {
          var target = {};
          for (let i in obj) {
            if (obj.hasOwnproperty(i)) {
              target[i] = obj[i];
            }
          }
          return target;
        }
        
深拷贝的方法：1.利用JSON.stringfy 和 JSON.parse 把一个对象转成json字符串在转成json对象
			2.递归也能吧应该
```



### 8.谈谈防抖和节流

```
防抖节流就是使用定时器来实现我们的目的。
防抖(debounce)：
    在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。
    典型的案例就是输入框搜索：输入结束后n秒才进行搜索请求，n秒内又输入的内容，则重新计时。
    
节流(throttle)：
    规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效。
    典型的案例就是鼠标不断点击触发，规定在n秒内多次点击只生效一次。
为什么要掌握防抖和节流
	函数节流与函数防抖都是可以限制函数的执行频次，根据不同的场景来对执行频率进行限制，避免了函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。
```

### 9.谈谈cookie,sessionStorage和localStorage

```
相同点：
cookie、sessionStorage和localStorage都用在客户端存储数据，每一个都有自己的存储和到期限制
不同点：
一、存储大小
cookie数据大小不能大于4K；
localStorage 和sessionStorage则可以达到5M；
二、有效时间
cookie在设置的有效期内一直有效；
localStorage存储持久数据，只要不手动清除则一直存在；
sessionStorage数据在当前浏览器关闭后就会被自动清除
三、数据与服务器间的交互方式
cookie的数据会自动传递到服务器端，服务器端也可以写cookie到客户端
localStorage和sessionStorage不会把数据自动传到服务器端，仅在本地存储


	localStorage
  定义：localStorage.setItem('key','value')
  获取：localStorage.getItem('key')
  删除：localStorage.removeItem('key')
  清空：localStorage.clear()
```

​              

### 10.0.1+0.2!=0.3怎么处理

```
在计算机中数字无论是定点数还是浮点数都是以多位二进制的方式进行存储的,计算机天生只能存储整数，它只能用某种方法来表示小数
解决方法：
1.把计算数字 提升 10 的N次方 倍 再 除以 10的N次方。N>1.
(0.1*10+ 0.2*10)/10== 0.3//true
2.四舍五入  tofixed
```

### 11.数组的常用方法(map至少说出8个)

```
答：在开发中，数组使用频率很频繁，JS数组常用方法有:push,pop,unshift,shift,splice,join,concat,forEach,filter,map,sort,some,every好多，不过都是平时开发中很常用的方法,大家可以补充一点儿es6的
1.shift 删除数组中的第一个元素 
2.pop 删除数组中的最后一个元素
3.unshift 增加元素在数组的前面 
4.push 增加元素在数组的后面
5.map 循环，并且返回新的数组 
6.forEach 循环，遍历
7.filter 过滤，筛选出数组中的满足条件的，并且返回新的数组
8.join将数组转为字符串

9.concnt 合并数组
10.find 查找出第一个符合条件中的数组元素
11.findIndex 查找出第一个符合条件中的数组元素，所在的索引位置
12.flat 将多维数组转为一维数组
13.reverse 颠倒数组中的顺序
14.every检测数组中元素是否都是符合条件 === bollean
15.some检测数组中元素是否有满足条件的元素 === bollean
16.splice(start,n,添加元素) 开始位置 删除个数，添加元素
17.sort 排序
18.slice(start,end) 选中[start.end)之间的元素
19.indexOf 查找值所在的位置
20.includes 查看数组中是否存在此元素




forEach、for in、for of
 forEach更多的用来遍历数组
 for in 一般常用来遍历对象或json
 for of数组遍历，遍历对象需要通过和Object.keys()
 for in循环出的是key，for of循环出的是value
```

### 11.forEach、fifter、map、some、every区别

```
1.forEach:这个方法是为了取代for循环遍历数组的，返回值为undefined例如：
     	let arrInfo=[4,6,6,8,5,7,87]
		arrInfo.forEach((item,index,arr)=>{
    		//遍历逻辑
		})
	其中：
  		item代码遍历的每一项,
  		index:代表遍历的每项的索引，
  		arr代表数组本身
2.filter:是一个过滤遍历的方法，如果返回条件为true，则返回满足条件为true的新数组
    	let arrInfo=[4,16,6,8,45,7,87]
             let  resultArr=arrInfo.filter((item,index,arr)=>{
    		//例如返回数组每项值大于9的数组
    		return item>9
		})

3.map:这个map方法主要对数组的复杂逻辑处理时用的多，特别是react中遍历数据，也经常用到，写法和forEach类似
4.some:这个some方法用于只要数组中至少存在一个满足条件的结果，返回值就为true,否则返回fasel, 写法和forEach类似
5.every:这个every方法用于数组中每一项都得满足条件时，才返回true，否则返回false, 写法和forEach类似
```

### 12.new一个对象的过程

```
1. 创建空对象；
var obj = {};
2. 设置新对象的constructor属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的prototype对象；
obj.__proto__ = ClassA.prototype;
3. 使用新对象调用函数，函数中的this被指向新实例对象：
ClassA.call(obj);//{}.构造函数();
4. 将初始化完毕的新对象地址，保存到等号左边的变量中
```

### 13. get和post区别

```
答：get 和 post 都是http协议中的两种请求方式，get一般用于获取数据，post一般用于传输数据
    1.get 比 post更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息 
    2.get是传输数据大小限制最大32k,post没有
    3.get在浏览器退回时不会再向浏览器发请求，而post会再次请求
    4.get只能进行url编码，而post支持多种编码方式
```

| **请求方式**   | **GET**                            | **POST**                   |
| -------------- | ---------------------------------- | -------------------------- |
| 参数位置       | 参数拼接到url的后面                | 参数在请求体中             |
| 参数大小       | 受限于浏览器url大小，一般不超过32K | 1G                         |
| 服务器数据接收 | 接收1次                            | 根据数据大小，可分多次接收 |
| 适用场景       | 从服务器端获取数据                 | 向服务器提交数据           |
| 安全性         | 参数携带在url中，安全性低          | 相对于GET请求，安全性更高  |



### 14.缓存的理解

```
缓存分为强缓存和协商缓存。
	强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
强缓存:
Expires  http1.0
cache-control  http1.1
协商缓存:
Last-Modified 和 If-Modified-Since    http1.0
Etag 和 If-None-Match    http1.1
```

### 17.Js事件循环机制 宏任务微任务【重要】

```
在线程之内，又被分为了两个队列：同步任务队列,异步任务队列

执行宏任务script，
进入script后，所有的同步任务主线程执行
所有宏任务放入宏任务执行队列
所有微任务放入微任务执行队列
先清空微任务队列，
再取一个宏任务，执行，再清空微任务队列
依次循环



同步环境执行(step1) -> 事件循环1(step4) -> 事件循环2(step4的重复)…
　　其中的异步进程有：
　　　　a、类似onclick等，由浏览器内核的DOM binding模块处理，事件触发时，回调函数添加到任务队列中；
　　　　b、setTimeout等，由浏览器内核的Timer模块处理，时间到达时，回调函数添加到任务队列中；
　　　　c、Ajax，由浏览器内核的Network模块处理，网络请求返回后，添加到任务队列中。
异步执行的运行机制
（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
（4）主线程不断重复上面的第三步。


```

### 20.闭包的理解

```
闭包，也叫高阶函数吧，简单来讲就是函数嵌套函数，外层函数返回一个函数，而返回的函数使用外层函数的参数和变量，参数不会被垃圾回收机制回收

优点：可以隔离作用域，避免全局污染；
缺点：由于闭包长期驻留内存，使用不当会造成内存泄露

解决内存泄露问题：将暴露全外部的闭包变量置为null

适用场景：封装组件，for循环和定时器结合使用,for循环和dom事件结合.可以在性能优化的过程中,节流防抖函数的使用,导航栏获取下标的使用
```

### 21.原型和原型链

```
原型： js万物皆对象吧，每一个对象都拥有自己的属性， js为了能让多个对象共享一个或多个方法，所以有了原型吧，js中每个对象都有一个与他关联的的对象，叫做原型对象
每一次获取对象属性都是一次查询过程，在对象的自有属性中查询不到就会查找他的原型对象

原型分为隐式原型和显式原型，每个对象都有一个隐式原型，它指向自己的构造函数的显式原型。

原型链： 多个__proto__组成的集合成为原型链
原型连成一条链，js在查找属性过程中，如果在自有属性中找不到就会去原型对象中去查找，如果原型对象中还查找不到，就去原型对象的原型去查找，也就是原型链查找，知道查找到原型链的顶端Object

所有实例的__proto__都指向他们构造函数的prototype
所有的prototype都是对象，自然它的__proto__指向的是Object()的prototype
所有的构造函数的隐式原型指向的都是Function()的显示原型
Object的隐式原型是null
```

### 22.继承

```
原型继承、组合继承、寄生组合继承、ES6的extend

1.原型继承
    // 把父类的实例作为子类的原型
    // 缺点：子类的实例共享了父类构造函数的引用属性   不能传参
    var person = {
      friends: ["a", "b", "c", "d"]
    }
    var p1 = Object.create(person)
    p1.friends.push("aaa")//缺点：子类的实例共享了父类构造函数的引用属性
    console.log(p1);
    console.log(person);//缺点：子类的实例共享了父类构造函数的引用属性

2.组合继承
    // 在子函数中运行父函数，但是要利用call把this改变一下，
    // 再在子函数的prototype里面new Father() ,使Father的原型中的方法也得到继承，最后改变Son的原型中的constructor
    // 缺点：调用了两次父类的构造函数，造成了不必要的消耗，父类方法可以复用
    // 优点可传参，不共享父类引用属性
    function Father(name) {
      this.name = name
      this.hobby = ["篮球", "足球", "乒乓球"]
    }
    Father.prototype.getName = function () {
      console.log(this.name);
    }
    function Son(name, age) {
      Father.call(this, name)
      this.age = age
    }
    Son.prototype = new Father()
    Son.prototype.constructor = Son
    var s = new Son("ming", 20)
    console.log(s);

3.寄生组合继承
    function Father(name) {
      this.name = name
      this.hobby = ["篮球", "足球", "乒乓球"]
    }
    Father.prototype.getName = function () {
      console.log(this.name);
    }
    function Son(name, age) {
      Father.call(this, name)
      this.age = age
    }
    Son.prototype = Object.create(Father.prototype)
    Son.prototype.constructor = Son
    var s2 = new Son("ming", 18)
    console.log(s2);

ES6的extend（寄生组合继承的语法糖）
    // 子类只要继承父类，可以不写 constructor ，一旦写了，则在 constructor 中的第一句话
    // 必须是 super 。
    class Son3 extends Father { // Son.prototype.__proto__ = Father.prototype
      constructor(y) {
        super(200)  // super(200) => Father.call(this,200)
        this.y = y
      }
    }
	ES6的继承：关键字：extends 继承、super 超级
	1、constructor  构造器里面的this是指向创建的实例对象
	2、方法里面的this都是指向 谁 调用这个方法就指向 谁

```

### 23.原生事件绑定

```
JS原生绑定事件主要为三种：
		一是html事件处理程序
		二是DOM0级事件处理程序
		三是DOM2级事件处理程序
		
1.html事件现在早已不用了，就是在html各种标签上直接添加事件，类似于css的行内样式，缺点是不好维护，因为散落在标签中,也就是耦合度太高
例如：<button onclick=”事件处理函数”>点我</button>

2.DOM0级事件，目前在PC端用的还是比较多的绑定事件方式，兼容性也好，主要是先获取dom元素，然后直接给 dom元素添加事件
例如：var btn=document.getElementById(‘id元素’)
      btn.onclick=function() {
         //要处理的事件逻辑
      }
DOM0事件如何移除呢？很简单：btn.onclick=null;置为空就行
   优点：兼容性好
   缺点：只支持冒泡，不支持捕获
   
3.DOM2级事件，移动端用的比较多，也有很多优点，提供了专门的绑定和移除方法
例如： var btn=document.getElementById(‘id元素’)
      btn.addEventListener(‘click’,绑定的事件处理函数名,false)//绑定事件
移出：btn.removeEventListener(‘click’,要移除的事件处理函数名，false)//移除事件 
优点：支持给个元素绑定多个相同事件，支持冒泡和捕获事件机制

```

### 23.JS设计模式(单例、观察者模式等)

```
答：JS设计模式有很多，但我知道的有单例模式，观察者模式

	单例模式：就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。
	在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。
 
	观察者模式: 观察者的使用场合就是：当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。

总结：总的来说，观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化
```

### 24.输⼊url按回⻋键后发⽣了什么 

```
1.输⼊url
2.DNS解析域名  找到这个域名对应的服务器地址(ip)
3.客户端发送http请求 
4.TCP传输报⽂ 
5.IP协议查找MAC地址 
6.数据到达数据链路层 
7.服务器接收数据 
8.服务器响应请求 
9.返回相应数据 
10.页面渲染

1. 首先浏览器主进程接管，开了一个下载线程。 
2. 然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。 
3. 将下载完的内容转交给Renderer进程管理。 
4. Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签 放在页面顶部。 
5. 解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时 候缓存的使用缓存，不适用缓存的重新下载资源。 
6. css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout， 开始计算每一个节点的位置，然后进行绘制。 
7. 绘制结束后，关闭TCP连接，过程有四次挥手
```

### 25. JS作用域和作用域链

```
作用域，JS作用域主要包括全局作用域、局部作用域和ES6的块级作用域

1.全局作用域：也就是定义在window下的变量范围，在任何地方都可以访问，
2.局部作用域：是只在函数内部定义的变量范围
3.块级作用域：简单来说用let和const在任意的代码块中定义的变量都认为是块级作用域中的变量，例如在for循环中用let定义的变量，在if语句中用let定义的变量等等

注：尽量不要使用全局变量，因为容易导致全局的污染，命名冲突，对bug查找不利。

作用域链就是由最内部的作用域往最外部,查找变量的过程.形成的链条就是作用域链
```

### 26.git

```
 git常用命令
 
     git add . 将当前目录所有内容(文件和文件夹) 都添加到 暂存区
     git commit –m "注释" 将暂存区的内容 存入本地仓库
     git push origin+分支名 将本地仓库推送到 远程地址
     git pull 拉取代码更新仓库
     git status 查看状态
     git --help 帮助
	 git log  查看日志
	 git clone 克隆仓库
	 
遇到代码冲突
git pull之后遇到冲突，
首先是和同事沟通，手动解决冲突代码之后，
再git add、git commit 、git push上传到远程仓库
```

### 27.axios数据是如何数据交互的

```
axios拦截器：
// 添加请求拦截器
axios.interceptors.request.use
// 添加响应拦截器
axios.interceptors.response.use

1.说一下你是如何与后端进行数据交互的
答：我和后端通过axios来进行数据交互的，通过统一制定的接口文档，来实现前后端高效开发，
如果接口文档不能详细说明，或者接口文档上的参数请求不出数据，我会主动和后端沟通嘛，直到完成跟接口相关的业务开发。
当然这其中为了验证一些接口问题，会用到一些辅助工具，比方说postman、runapi 这种在线测试工具

2.如果后端数据接口没有准备好，你是如何工作的
答：如果后端接口还没有准备好，我会和后端沟通，通过制定接口返回数据的格式，然后前端通过一些mock数据的工具（上家公司使用的是mock）来批量生成假数据，可以让前端和后端同时开发，而无需等待后端数据接口写好再开发，这样提升项目整体的开发效率
```

### 28.同源策略跨域

```
浏览器的同源策略会引起跨域问题

同源策略是因为安全的考虑，不允许访问不同域名下的资源

产生跨域的情况有：不同协议，不同域名，不同端口以及域名和ip地址的访问都会产生跨域。
跨域是浏览器做出的限制,和后端没关系


1.jsonp用的比较少
    jsonp实现原理：主要是利用动态创建script标签请求后端接口地址，然后传递callback参数，后端接收callback，后端经过数据处理，返回callback函数调用的形式，callback中的参数就是json
    
2.代理（前端代理和后端代理）
	前端代理我在vue中主要是通过vue脚手架中的config中的index文件来配置的，其中有个proxyTable来配置跨域的

3.CORS 
	CORS全称叫跨域资源共享，主要是后台工程师设置后端代码来达到前端跨域请求的
	cors最佳，只需要在服务器添加一个白名单允许访问就可以了

注：现在主流框架都是用代理和CORS跨域实现的
```

### 29.原生ajax的交互过程

```
答：交互流程：
       1.先创建XHR对象即XMLHttpRequest()
       2.然后open准备发送，open中有三个参数一是提交方式get和post,二是接口地址，三是同步和异步
       3.第三步是用send发送
       4.第四步再发送的过程中通过onreadystatechange来监听接收的回调函数，可以通过判断readyState＝＝4和status=＝200来判断是否成功返回，然后通过responseText接收成功返回的数据
```

### 30.同步和异步的理解

```
答：js是单线程嘛，同步即sync，形象的说就是代码一行行执行，前面代码和请求没有执行完，后面的代码和请求就不会被执行，
缺点：容易导致代码阻塞
优点：程序员容易理解（因为代码从上往下一行行执行，强调顺序）

异步：即async,形象的说就是代码可以在当前程序没有执行完，也可以执行后面的代码
缺点：难读懂代码（因为不是按顺序执行的）
优点：可以解决代码阻塞问题，提升代码执行效率和性能

异步解决方案主要有三个：
1.	回调函数
2.	promise（重点掌握）
3.	generator(了解)
4.	async和await（重点掌握）

```

### 30.var、let、const之间的区别

```
var声明变量可以重复声明，而let不可以重复声明
var是不受限于块级的，而let是受限于块级
var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错
const声明之后必须赋值，否则会报错
const定义不可变的量，改变了就会报错
```

### 31.箭头函数

```
（1）用了箭头函数，this就不是指向window，而是父级（指向是可变的）
（2）不能够使用arguments对象，（该对象在函数体内不存在。如果要用，可以用 rest 参数代替。）
（3）不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误
（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数
```

### 30.promise

```
可以把 promise 当作一个装着异步操作结果的容器,比传统的回调函数解决方案更合理和更强大吧。 从语法上说：Promise 是一个对象， Promise 提供统一的 API，它将异步函数以同步的方式书写，也解决了回调地狱问题

它有三个状态： 进行中、已成功、以失败。
两种结果： 进行中—>已成功（resolved） 
		  进行中—>已失败（rejected）

特点：对象状态不受外界影响一旦状态改变，就不会再变

promise原型下面两个方法
then：resolve函数将Promise对象的状态变为“成功”，找then方法，将resolve函数的参数值传递给then方法。promise构造函数是同步执行的，then方法是异步执行的
catch：reject函数将Promise对象的状态变为“ 失败”，找catch方法，将reject函数的参数值传递给catch方法。

Promise的两个静态方法
Promise.all()：用于将多个 Promise 实例，包装成一个新的 Promise 实例，接受一个数组作为参数，只有数组里面的每个状态都变成resolve，则新的Promise实例状态才会变成resolve.
Promise.race()：方法同样是将多个Promise实例，包装成一个新的 Promise 实例，接受一个数组作为参数，只要其中有一个实例率先改变状态，则整个的状态就跟着改变(谁快跟着谁走)。

缺点： 
第一点，无法取消 promise，一旦新建它就会立即执行，无法中途取消 
第二点，如果不设置回调函数，promise 内部抛出的错误，不会反应到外部 
第三点，无法得知目前进展到哪一个阶段（刚刚开始还是即将结束） 
```

### 31.Promise 中reject 和 catch 处理上有什么区别

> reject 是用来抛出异常，catch 是用来处理异常
> reject 是 Promise 的方法，而 catch 是 Promise 实例的方法
> reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch
> 网络异常（比如断网），会直接进入catch而不会进入then的第二个回调

### 31.async和await

```
async await**也是异步编程的一种解决方案，拥有promise的风格，他遵循的是Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，async修饰过的函数也有then和catch⽅法，await只能放在async中，只能修饰promise对象

它返回的是一个Promise对象。
```

**两者的区别：**

Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。

async await与Promise一样，是非阻塞的。

async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。

### 32.模板字符串

```
 可以使用反引号``   ``来进行字符拼接${} 
```

### 33.解构赋值...

```
...解构从数组和对象提取值并赋值
const point = [10, 25, -34];
const [x, y, z] = point;
console.log(x, y, z);
```

### 34. 拓展运算符...

```

```

### 34. for...of（和for...in的区别）

for...of遍历数组

```
1.for (var i = 0; i < arr.length; i++) {
        document.write("for循环:" + arr[i] + "," + i + "<br>")
    }
for循环:10,0
	
	
	
2.for (var i in arr) {
        document.write("for...in遍历:" + arr[i] + "," + i + "<br>")
    }
for...in遍历:10,0



3.for (var item of arr) {
        document.write("for...of遍历:" + item + "," + arr[item] + "<br>")
    }
for...of遍历:10,undefined



4.arr.forEach((item, index) =>
        document.write("forEach遍历:" + item + "," + index + "<br>")
    )
forEach遍历:10,0
```

 for...in 用来遍历对象

```
     var person = {
        username: "zhangsan",
        age: 18,
        sex: "nan"
    }
    for (var attr in person) {
        document.write("对象的for...in遍历" + attr + "," + person[attr] + "<br>")
    }
    
对象的for...in遍历username,zhangsan
```

### 35.**导入导出**

```
导入improt
导出export default
```

### 36.Symbol数据类型

### 37.Map和Set新的对象和方法

```
高效去重的一个方法 new Set()

let arr = [1,1,2,3,4,4];
let mySet = new Set(arr);
let newArr = Array.from(mySet);
console.log(newArr);  *//[1,2,3,4]
```

### 38.Async await （es7的特性）

```
async**作为一个关键字放在函数的前面，表示该函数是一个异步函数，意味着该函数的执行不会阻塞后面代码的执行 异步函数的调用跟普通函数一样，返回结果是一个Promise对象，要获取Promise的返回值应该用then方法
**await**即等待，用于等待一个Promise对象。它只能在异步函数 async function中使用，否则会报错
它的返回值不是Promise对象而是Promise对象处理之后的结果
await表达式会暂停当前 async function的执行，等待Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 async function，若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。如果 await 操作符后的表达式的值不是一个 Promise，那么该值将被转换为一个已正常处理的 Promise。

async和await需要配合使用，主要也是为了解决promise的链式调用形成回调地狱而提出来的方案
```

### 39.http状态码

```
2开头的表示成功一般见到的就是200
3开头的表示重定向301永久重定向
	302临时重定向
	304表示可以在缓存中取数据（协商缓存）
4开头表示客户端错误
	400一般参数错误
	403没有权限
	404请求资源不存在
5开头表示服务端
	错误500
```

### 40.图片懒加载

```
图片懒加载就是处理图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。

我们在项目中使用 Vue 的 vue-lazyload 插件：
1.安装插件
2.在入口文件 man.js 中引入并使用
3.在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：
	<img v-lazy="/static/img/1.png">
 
```

### 41.异步解决方案有哪些？

```
1.回调函数callback：回调地狱：多个回调函数嵌套的情况，使代码看起来很混乱，不易于维护。

2.事件发布订阅:消耗内存，过度使用会使代码难以维护和理解

3.Promise:无法取消promise。如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。当处于Pending状态时，无法得知目前进展到哪一个阶段

4.Generator:Generator是es6提出的另一种异步编程解决方案，需要在函数名之前加一个*号，函数内部使用yield语句。Generaotr函数会返回一个遍历器，可以进行遍历操作执行每个中断点yield,不能自动执行异步操作，需要写多个next()方法. 

5.async/await:es2017引入的异步操作解决方案，可以理解为Generator的语法糖，最重要的好处是同步编程风格,async 函数返回一个 Promise。内置执行器，比Generator操作更简单。async/await比*yield语义更清晰。返回值是Promise对象，可以用then指定下一步操作。代码更整洁。可以捕获同步和异步的错误。
```

42.发布者订阅模式



```
发布者-订阅者模式又称观察者模式：当一个对象（发布者）状态发生改变时，所有依赖它的对象（订阅者）都会得到通知。

该模式广泛应用在异步编程中：我们无需关注对象在异步运行期间的内部状态，只需要订阅感兴趣的事件发生点。

简单说就是该模式让发布者和订阅者两个对象弱耦合，虽然不太清楚彼此的细节但是不影响彼此通信。
```



# 5.vue面试题

### 1. 对vue的认识

```
Vue 是一套用于构建用户界面的渐进式JS框架
与其它大型框架不同的是，轻量级框架，可以自底向上逐层应用
Vue 的核心库只关注视图层，不仅易于上手，还易于结合其他第三库或既有项目整合。

优点：组件化开发 单页面路由 丰富的Api方法 双向的数据绑定 单向数据流 易于结合其他第三库


vue最大特点我感觉就是“组件化“和”数据驱动“
   组件化就是可以将页面和页面中可复用的元素都看做成组件，写页面的过程，就是写组件，然后页面是由这些组件“拼接“起来
   数据驱动就是让我们只关注数据层，只要数据变化，页面（也就是视图层）会自动更新，至于如何操作dom，完全交由vue去完成，咱们只关注数据，数据变了，页面自动同步变化了，很方便





组件化开发通过 vue 的模块封装，可以将一个 web 开发中设计的各种模块进行拆分，变成单独的组件，然后 通过数据绑定，调用对应模板组件，同时传入参数，即可完成对整个项目的开发
它采用 MVVM的模式，m 是 model，v 是 view，vm 是 viewmodel，是通过 viewmodel 去改变 view 层和 model 层，view和model 随两者之间的变化而变化，vue 与其他框架相比优点是采用双向数据绑定并且使用虚拟dom，组件化开发提高开发的效率。
```

### 2. vue 单向数据流的理解

```
答：单向数据流主要是vue 组件间传递数据是单向的，就是说是由父组件传递给子组件，子组件在其内部维护自己的数据，但它无权修改父组件传递给它的数据，当开发者尝试这样做的时候，vue 将会报错。这样做是为了组件间更好的维护。

在开发中可能有多个子组件依赖于父组件的某个数据，假如子组件可以修改父组件数据的话，一个子组件变化会引发所有依赖这个数据的子组件发生变化，所以 vue 不推荐子组件修改父组件的数据
```

### 3.vue单页面应用及其优缺点

```
单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。

单页面的优点：
	所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。
	
单页面缺点：
 不利于搜索引擎的抓取
 首次渲染速度相对较慢
```

### 4. vue和react的区别

**相同点**

```
都有组件化思想
数据驱动视图
都有自己的构建工具：Vue的vue-cli、React的Create React App
都支持服务器端渲染
都有Virtual DOM（虚拟dom）
都有支持native的方案：Vue的weex、React的React native
```

**区别**

```
写法上有区别
1.数据流向的不同。react是单向数据流，而Vue是双向数据流
2.数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据
3.组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数
4.diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM
```

###  5. vue 指令

```text
v-html   //html
v-text   //元素里要显示的内容
v-bind：data    //绑定动态数据   ：data
v-on：click      //绑定事件       @click
v-for
v-show
v-if　　 //条件渲染指令
v-model    //双向绑定，用于表单
```

### 6. v-show和v-if区别

```
v-show通过css display控制显示和隐藏，v-if组件真正的渲染和销毁，而不是显示和隐藏，频繁切换状态使用v-show 否则v-if
v-if 常用于一次性改变，如根据权限决定是否显示
v-show 用于 tabs 切换
v-if 可与 templete块连用 ，v-show 不支持 <template> 元素，也不支持 v-else
v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗
v-if 是控制元素的添加与删除，而 v-show 只是控制元素的 display 属性。
```

### 7. v-for要用key的原因

```
快速查找到节点，减少渲染次数，提升渲染性能
```

### 8. vue生命周期【重要】

```
大致可分为创建、挂载、更新、销毁阶段

挂载： beforeCreate => created（初始化） => beforeMount => mounted（首屏）
更新： beforeUpdate => updated
销毁： beforeDestroy => destroyed
如果使用keep-alive缓存动态组件会多出来两个生命周期activated 和 deactivated 

created：
	初始化$el 属性还没有显示出来
mounted：
	首屏、还有一些dom操作
beforeDestroy：
	1.解绑自定义事件event.$off2.清除定时器3.解绑自定义dom事件，如windom.scroll等
```

父子组件生命周期图
挂载： parent beforeCreate => parent created => parent beforeMount => child beforeCreate => child created => child beforeMount => child mounted => parent mounted
更新： parent beforeUpdate => child beforeUpdate => child updated => parent updated
销毁： parent beforeDestroy => child beforeDestroy => child destroyed => parent destroyed
从以上能够看出：
挂载时，子组件是在父组件before mount后开始挂载，并且子组件先mounted，父组件随后
更新时，子组件是在父组件before update后开始更新，子组件先于父组件更新
销毁时，子组件是在父组件before destroy后开始销毁，并且是子组件先销毁，父组件随后。

### 9.为什么做首屏优化，如何首屏优化？

```
首屏时间的快与慢，直接影响到了用户对网站的认知度。所以首屏时间的长短对于用户的滞留时间的长短、用户转化率都尤为重要。


如何首屏优化？
css模块化加载，对应模块下的css交给js或jsonp请求返回
js懒执行，有交互才执行
图片在其他屏（非首屏）都采用懒加载的模式，这样既能节省流量，也能减少请求数或延迟请求数。
服务器方面：

1. 少量静态文件的域名，图片与iconfont均是放在同一个域下，减少DNS的解析事件，最好做到域名收敛。
2. 模块化接口的支持。
3. 首屏内容最好做到静态缓存
4. 对于vue和react做ssr
```



### 10. 组件通信（组件传值）【重要】

```
常见使用场景可以分为三类：父子通信、兄弟通信、跨层级通信

父子通信  父向子传递数据是通过 props，子向父是通过（this.$emit）
		 ref也可以
兄弟通信：事件总线通信event.bus通信 vuex
跨层级通信：provide和inject组件通信 vuex

```

1.父子组件props和this.$emit
2.ref 链：父组件要给子组件传值，在子组件上定义一个 ref 属性，这样通过父组件的 $refs 属性就可以获取子组件的值了，也可以进行父子，兄弟之间的传值($parent / $children与 ref类似)
3.事件总线bus：使用一个 空的 VUE 实例作为事件总线，自定义事件event.$on   event.$off  event.$emit
4 provide  inject组件通信
5.vuex
6.$attrs和$listeners 仅仅是传递数据，而不做中间处理，$attrs 里存放的是父组件中绑定的非 Props 属性，$listeners里存放的是父组件中绑定的非原生事件。

常见使用场景可以分为三类：
父子通信：
	父向子传递数据是通过 props，子向父是通过 events（$emit）；
	通过父链 / 子链也可以通信（$parent / $children）；
	ref 也可以访问组件实例；
	provide / inject API；
	$attrs/$listeners
	vuex
兄弟通信：
	事件总线Bus；
	Vuex
跨级通信：
	事件总线Bus；
	Vuex；
	provide / inject API
	$attrs/$listeners

### 11.  描述组件渲染和更新的过程

```
1、vue 组件初次渲染过程
    compile模板转化为render函数
    转化data响应数据，把data编程set get函数
    执行render函数，把模板转化为虚拟dom
    调用patch函数虚拟dom挂载到节点上

2、vue 组件更新过程
	触发响应数据里面的set函数
	执行render函数，模板重新编译转化为vdom
	通过diff算法中 patch函数 比较虚拟节点 挂载 结束
```

### 12.  双向数据绑定v-model的实现原理【重要】

```
双向数据绑定，采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调，从而就达到监听数据变动的目的.



v-model其实是一个语法糖，他背后本质上是包含两个操作：v-bind绑定一个value属性，v-on指令给当前元素绑定input事件，然后ev.target.value赋值给状态

先是从data里面的数据msg通过绑定到input控件和p标签上。然后input上通过v-on:input监听控件，触发change()事件。
调用方法都可以默认获取e事件，e.target.value是获取调用该方法的DOM对象的value值。把value值在赋给data里的msg，就是实现了双向数据绑定的原理了。

    <p>{{msg}}</p>
    <input type="text" :value="msg" @input="Fun" />
    
    data() {
       return {
         msg: "11"
        };
     },
    methods: {
      Fun(ev) {
        this.msg = ev.target.value;
       }
     }
```

### 13. 对mvvm的理解

```
m->model,v->view,vm->viewModel。
dom通过监听事件操作vue里的data，反之vue中的data通过指令操作dom，这就是所说数据驱动视图
```

### 14. 路由router【重要】

```
有两种模式，hash模式和history模式，
两种跳转方式 命令式导航<router-link>和编程式导航this.$router.push("/about");，
通过query传参和params传参
this.$route.query或者this.$route.params接受参数

声明式导航：query传参
    <router-link to="/about?name=王五">跳转about</router-link>
编程式导航：params传参（需要动态路由支持）
    <button @click="myClick">跳转</button>
     methods: {
    	myClick() {
      		this.$router.push("/about/王五");
    	}
     }
```

**router路由模式                        hash  模式、 history模式**

```
hash模式，监听hashchange事件实现前端路由，利用url中的hash来模拟一个hash，以保证url改变时，页面不会重新加载。
history模式，利用pushstate和replacestate来将url替换但不刷新，但是有一个致命点就是，一旦刷新的话，就会可能404，因为没有当前的真正路径，要想解决这一问题需要后端配合，将不存在的路径重定向到入口文件。
```

 **$router和$route的区别**

```
$router为VueRouter的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等。
$route 是路由信息对象 跳转的路由对象，每一个路由都会有一个route对象，是一个局部对象
		包含path,params,hash,query,fullPath,matched,name等路由信息参数。
```

**router路由守卫**

```
1.全局路由守卫 beforeEach
router.beforeEach((to,from,next)=>{ //全局路由前置守卫
 	console.log(to); //新的路由对象
 	console.log(from); //旧路由对象
	next() ///vue2.0 必须写  vue3.0不用写
})

2.路由独享守卫 beforeEnter
beforeEnter:(to,from,next)=>{ 
   next();
}
```

**vue-router路由异步加载**

```
component:() => import('./component')
```



#### 说一下路由守卫 钩子函数都有哪些？

```
钩子函数有三种 ,也叫路由守卫

全局导航钩子（跳转前进行判断拦截）  全局路由守卫
router.beforeEach(to, from, next),全局前置守卫
router.beforeResolve(to, from, next),全局的解析守卫
router.afterEach(to, from ,next) 全局的后置守卫

组件内钩子    路由独享的守卫
beforeRouteEnter
beforeRouteUpdate
beforeRouteLeave 
单独路由独享组件

beforeEnter   组件内的守卫
```



#### 18.如何配置vue-router路由异步加载

```
component:() => import('./component')
```



#### 28.$route和 $router的区别是什么？

```
 $router为VueRouter的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等。
 
 $route 是路由信息对象||跳转的路由对象，每一个路由都会有一个route对象，是一个局部对象，包含path,params,hash,query,fullPath,matched,name等路由信息参数。
```



### 15. vuex状态管理【重要】

```
就是一个专门为 vue  构建的状态管理工具，主要是为了解决多组件之间状态共享问题的，vuex 的核心包括五个属性： 
    state（存储数据的）、
    	获取数据最好推荐使用getters
		硬要使用的话可以用MapState，先引用，放在computed中...mapState(['方法名','方法名'])
    getters（获取数据的）、
    	this.$store.getters.xxx
		也可使用mapGetters 先引用，放在computed中，...mapGetters(['方法名','方法名'])
    mutations（同步 更改状态）、
        this.$store.commit(“方法名”,数据)
        也可使用mapMutations ，先引用，放在methods中
    actions （发送异步请求，拿到数据）、
        this.$store.dispatch(“方法名”,数据)
        也可使用mapActions ，先引用，放在methods中
    modules（模块划分）     
    	namespaced:true //开启
    
项目中比如玻璃的库存数量，出现过多个视图依赖于同一状态，还有来自不同视图的行为需要变更同一状态。所以把公共数据放在 vuex 当中。
state 发布一条新的数据，在 getters 里面根据状态派发新的状态，actions 发送异步请求获取数据，然后在 mutations 里面同步的更改数据 

在 state 中根据需求定义对象的属性，在 getters 里面根据状态派发新的状态，actions 发送异步请求 获取数据，委托给 mutation，然后在 mutations 里面同步的更改数据。然后抛出去。接着把 store.js 中的值，赋值给需 要的组件模板里 data 中的值。通过 computed 的计算属性直接赋值，或者通过辅助函数，然后解构出来。

store.js文件中,
mutations：{
		setNum(state, val) {
            state.num += val
        }
}
actions: {
        // 异步修改数据 mutations
        setNumAction({ commit }, val) {
            commit("setNum", val)
        }
    },
```

### 16. Vuex页面刷新数据丢失咋解决这个bug

```
F5页面刷新，页面销毁之前的资源，重新请求，因此写在生命周期里的vuex数据是重新初始化，无法获取的，这也就是为什么会打印出空的原因。


解决思路1：
使用Localstorage sessionStorage 或cookie
实际使用时当vuex值变化时，F5刷新页面，vuex数据重置为初始状态，所以还是要用到localStorage, 
解决方法2:
插件vuex-persistedstate
vuex-persistedstate默认持久化所有state，可以指定需要持久化的state
```

### 17.  vue项目做过哪些优化

```
（1）代码层面的优化 
    1.合理使用v-if和v-show，区分场景
    2.合理使用computed，和watch
    3.自定义事件，dom事件及时销毁，
    4.图片资源懒加载
    5.路由懒加载，大组件异步加载啊
    6.第三方插件的按需引入
    6.合理使用keepalive，
    3.v-for加key， 
    7.data层级不要太深，
    8.使用vue-loader在开发环境做模板编译，
    9.前端通用性能优化（如图片懒加载/
    				减少 HTTP请求数/
    				合理设置 HTTP缓存/
    				资源合并与压缩/
    				合并 CSS图片/
    				将 CSS放在 head中/
    				避免重复的资源请求/切分到多个域名），
    10.使用服务端渲染ssr
    服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。
    
（2）Webpack 层面的优化
    Webpack 对图片进行压缩
    减少 ES6 转为 ES5 的冗余代码
    提取公共代码
    模板预编译
    提取组件的 CSS
    优化 SourceMap
    构建结果输出分析
    Vue 项目的编译优化 
（3）基础的 Web 技术的优化
    开启 gzip 压缩
    浏览器缓存
    CDN 的使用
    使用 Chrome Performance 查找性能瓶颈
```



### 19.  computed、watch（自动监听、深度监听）、methods区别

```
computed：有缓存性、和依赖性。计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值，首屏执行一次。（当页面中有某些数据依赖其他数据进行变动的时候 ）
场景：checkbox的单选和全选

methods：只要发生重新渲染， method 调用总会执行该函数。

watch：监听对象需要深度监听，默认是浅监听。用于观察和监听页面上的vue实例，如果要在数据变化的同时进行异步操作或者是比较大的开销，那么watch为最佳选择。（watch用来监听外部的值，并且值被多次使用时，触发多次）

Computed使用场景：在项目描述中有一些信息需要拼接的时候
Watch的使用场景：监听url的变化，监听选项卡tab值的变化，tab不同就会调用不同的方法，去请求不同的数据
```

### 20.什么是$nextTick

```
场景：vue是异步渲染的框架，data改变之后，dom不会立刻渲染，$nextTick会在dom渲染之后被触发，以获取最新dom节点

this.$nextTick(() => {
	console.log(this.$refs.myUl);
});
```

### 21.   vue自定义指令

```
指令有全局指令和局部指令吧，全局组件directive
局部组件directives：{指令:{inserted:(el,val)=>{ el.style.color=val.value}}}

使用场景：输入框自动聚焦
Vue.directive(
  "focus", {
     "inserted": (el) => {
       el.focus()
     }
  }
)
```

### 22.  vue过滤器

```
过滤器是将后台返回的数据换一种形式输出，不改变原来的数据 

1. 全局过滤器    Vue.filter('过滤器',对应的过滤器函数)
2.局部过滤器		通过在Vue实例上挂载filers添加过滤器，只能在当前组件内部使用

应用场景:后台返回的状态码（性别，支付状态），商品价格 
```

### 22.  十个常用的自定义过滤器

```
（1）去除空格  
	type:1-所有空格  2-前后空格  3-前空格 4-后空格。
（2）任意格式日期处理
（3）字母大小写切换
	type:1:首字母大写 2：首页母小写 3：大小写转换 4：全部大写 5：全部小写
（4）字符串循环复制,count->次数.
（5）字符串替换
（6）字符替换*，隐藏手机号或者身份证号等
（7）格式化处理字符串
（8）现金额大写转换函数
（9）保留2位小数   0.3 + 0.9 ！= 1.2  
（10）补零
```

### 23.  $set()添加属性

```
vue中给某个对象添加一个新属性，但是dom没有响应数据的变化

Vue.js 不能检测到对象属性的添加或删除。

因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue.js 转换它，才能让它是响应的。

这时候可以使用this.$set()
mounted () {
    this.$set(this.student,"age", 24)
}
```

### 24.何时使用beforeDestroy？

```
1.解绑自定义事件event.$off
2.清除定时器
3.解绑自定义dom事件，如windom.scroll等
```

### 25.keep-alive？

```
缓存组件不需要重复渲染，多个静态tab页切换，优化性能
里面有两个属性：
include:字符串或正则表达式。只有匹配的组件会被缓存。
exclude：字符串或正则表达式。任何匹配的组件都不会被缓存。
```

### 26.vue异步渲染

```
因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以考虑性能问题，Vue会在本轮数据更新之后，再去异步更新视图
```

### 28. Vue.use()

```
场景:我们使用 element时会先 import,再 Vue.use()一下,实际上就是注册组件,触发 install 方法; 这个在组件调用会经常使用到; 会自动组织多次注册相同的插件.
```

### 29.组件中 data 为什么是一个函数？

```
vue中data必须是函数是为了保证组件的独立性和可复用性，data是一个函数，组件实例化的时候这个函数将会被调用，

返回一个对象，计算机会给这个对象分配一个内存地址，你实例化几次，就分配几个内存地址，他们的地址都不一样，所以

每个组件中的数据不会相互干扰，改变其中一个组件的状态，其它组件不变。



让每个返回的实例都可以维护一份被返回对象的独立的拷贝。
```

### 30.虚拟dom

```
将真实的html结构转换成js里的一个对象存在浏览器的内存里面，当我们去修改的时候，修改的不是真实的dom，而是js里的那个变量，当修改完成，再将js的对象转换成虚拟dom，再进行渲染
```

### 28.computed有何特性

```
缓存，data不变不会重新计算，提高性能
```

#### 29.ajax请求应该放在哪个生命周期？

```
mounted，因为js是单线程，ajax异步获取数据 
```

#### 30.何时要使用异步组件？

```
加载大组件，路由异步加载
```



#### 31.什么是作用域插槽？

```
在solt组件中有自己的data，把它传给使用的地方
```

#### 32.vuex中action和mutation有何区别？

```
action中处理异步，mutation不可以
mutation做原子操作，action可以整合多个mutation
```

#### 33.vue-router常用路由模式

```
hash默认，h5 histroy需要服务端支持
```



#### 34.监听data变化的核心api是什么？

```
vue2.0核心api是Object.defineProperty，vue3.0是启用proxy实现响应式
```

#### 35.vue如何监听数据变化？

```
vue中的watch监听数据变化
```

#### 36.监听数组变化（数组方法）？

```
监听数组变化：重写数组的push.pop.shift.unshift.splice.sort.reverse方法
```

####  24、vue 的指令用法

```text
v-html   //html
v-text   //元素里要显示的内容
v-bind：data    //绑定动态数据   ：data
v-on：click      //绑定事件       @click
v-for
v-if　　 //条件渲染指令
v-model    //双向绑定，用于表单
```



#### 25.vue中子组件调用父组件的方法?

```
1.直接在子组件中通过this.$parent.event来调用父组件的方法。
2.在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。
3.父组件把方法传入子组件中，在子组件里直接调用这个方法。
```

#### 26.vue页面级组件之间传值?

```
    1.使用vue-router通过跳转链接带参数传参。
    2.使用本地缓存localStorge。
    3.使用vuex数据管理传值
```

#### 27.说说vue的动态组件。

```
 多个组件通过同一个挂载点进行组件的切换，is的值是哪个组件的名称，那么页面就会显示哪个组件。
```



#### 29.为什么使用vue开发？

```
组件化开发 单页面路由 丰富的Api方法 双向的数据绑定 单向数据流 易于结合其他第三库
```



#### 31.双向数据绑定的理解？

```
vue采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty劫持data属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
```

#### 32.，v-if、v-for优先级

```
v-for和v-if不应该一起使用，必要情况下应该替换成computed属性。


原因：v-for比v-if优先，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候。
```

#### 35.ref 的作用？

```
获取dom元素 this.$refs.box
获取子组件中的data this.$refs.box.msg
调用子组件中的方法 this.$refs.box.open()
```

#### 36.什么是vuex？vuex核心包括？怎么修改state中数据？在项目中哪里使用？

```
vuex 是一个专门为 vue 构建的状态管理工具，主要是为了解决 多组间之间状态共享问题。强调的是集中式管理，（组件与组件之间的关系变成了组件与仓库之间的关系）
　　vuex 的核心包括：state（存放状态）、mutations（同步的更改状态）、actions（发送异步请求，拿到数据）、getters（根据之前的状态派发新的状态）、modules（模块划分）
　　state 发布一条新的数据，在 getters 里面根据状态派发新的状态，actions 发送异步请求获取数据，然后在 mutations 里面同步的更改数据
　　应用场合：地址、购物车的数据共享、登入注册
```



#### 38.data数据结构设计思路，组件化设计原则

```
data数据结构设计，或者问有哪些原则
原则：【{id:1,name:'zhangsan'}】
1.用数据描述所有的内容
2.数据要结构化，易于程序操作，遍历，查找
3.数据要可扩展，以便增加新的功能
组件如何设计，有什么原则
原则：
1.从功能上拆分层次
2.尽量让组件原子化，一个组件只做一件事情
3.容器组件（只管数据，一般是顶级组件）和展示组件（只管显示视图）
```

#### 39.有没有使用过axios、axios拦截器，跨域如何解决？

```
axios拦截器：
// 添加请求拦截器
axios.interceptors.request.use
// 添加响应拦截器
axios.interceptors.response.use

跨域特别注意两点：
第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，
第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。
vue如何解决跨域：
proxyTable   这里vue脚手架生成的标准项目为准。一般在项目config目录下面有个index文件
CORS   CORS即跨源资源共享，它定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。
Nginx  当我们明白跨越的含义之后。只要解决了'源'的问题。那么跨越也就不存在了
```



#### 43.vue常用的修饰符

```
.stop - 调用 event.stopPropagation()，禁止事件冒泡。
.prevent - 调用 event.preventDefault()，阻止事件默认行为。
.capture - 添加事件侦听器时使用 capture 模式。
.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
.native - 监听组件根元素的原生事件。
.once - 只触发一次回调。

v-model 指令常用修饰符：
.number - 输入字符串转为数字
.trim - 输入首尾空格过滤
.lazy
```

#### 44.v-on可以监听多个方法吗？

```
v-on可以监听多个方法，但是同一种事件类型的方法，vue-cli工程会报错
```





# 6.vue3.0面试题

### 1.Vue3.0和Vue2.0的区别

```
	完全兼容
	3.0比2.0 快2倍
 vue2.0响应式原理改变Object.defineProprety() ;vue3.0响应式改为Proxy


· 3.0去掉了filter, 么有beforeCreate created,用setup取代
· reactivity是可以单独作为库使用的 
· 单独功能可以抽离 取代了mixin  优于mixin 解决上下反复横跳
· 支持多个子节点 fragment
· setup里没有this
· Proxy实现响应式不需要set delete  兼容性并不好
· 响应式方面 性能得到很大提升 不用初始化的时候就递归遍历属性
· 响应式不区分数组和对象
· 3.0兼容IE12以上
· composition api 可以和 options API 同时存在

```

### 2.Vue3.0都有哪些重要新特性？

```
建议往`Composition API`和`Tree-shaking`方面答，对应比较`React Hooks`和webpack 的`Tree-shaking`
composition-api解决了什么问题
1.使用传统的option配置方法写组件的时候问题，随着业务复杂度越来越高，代码量会不断的加大；由于相关业务的代码需要遵循option的配置写到特定的区域，导致后续维护非常的复杂，同时代码可复用性不高，而composition-api就是为了解决这个问题而生的
compositon-api提供了一下几个函数
reactive
watchEffect
computed
ref
toRefs
生命周期的hooks

2.Vue3提出万物皆可 TreeShaking的概念
什么是 TreeShaking 
TreeShaking 是一个术语，指的是在打包构建过程中移除没有被引用到的代码，这些代码可以成为 dead code。这个概念最早在基于 ES6 的打包工具 Rollup 中提出，后来被引入到 webpack 中。TreeShaking 比较依赖于 ES6 模块系统的静态结构特性，比如 import 和 export。
```

### 3.Vue3.0` 对比`Vue2.0的优势在哪？

```
vue3.0 的发布与 vue2.0 相比，优势主要体现在：更快、更小、更易维护、更易于原生、让开发者更轻松；
更快
　　1、virtual DOM 完全重写，mounting & patching 提速 100%；
　　2、更多编译时 （compile-time）提醒以减少 runtime 开销；
　　3、基于 Proxy 观察者机制以满足全语言覆盖以及更好的性能；
　　4、放弃 Object.defineProperty ，使用更快的原生 Proxy；
　　5、组件实例初始化速度提高 100%;
　　6、提速一倍/内存使用降低一半；
更小
　　1、Tree-shaking 更友好；
　　2、新的 core runtime：~ 10kb gzipped
```





# 7.兼容性面试题

###  1.**移动端设计稿尺寸** 

```
 1.定宽布局
 2.一般移动端设计稿是750的尺寸（或者640）
```

### **2.移动布局自适应不同屏幕的几种方式**

```
（1）响应式布局

（2）100%布局（弹性布局）

（3）等比缩放布局（rem）
```

### **3.你们做移动端平时在什么浏览器上测试？**

```
   Chrome，Safari，微信X5，UC，其他手机自带浏览器
```

### 4.移动端怎么固定横屏显示？**

```
检测手机竖屏的时候，元素给元素添加90deg的旋转

检测手机横屏的时候，元素给元素的旋转再改为0
```



### 1.html5调用安卓或者ios的拨号功能

html5提供了自动调用拨号的标签，只要在a标签的href中添加tel：就可以了。如下：
< a href=" ">400-810-6999 转 1034</ a>
拨打手机如下：
< a href="tel:15677776767">点击拨打 15677776767 </ a>

##### 2.上下拉动滚动条时卡顿、慢

   body {
		-webkit-overflow-scrolling: touch; 
		overflow-scrolling: touch;
	}
 Android3+和 iOS5+支持 CSS3 的新属性为 overflow-scrolling。

##### 3.圆角bug

某些 Android 手机圆角失效
background-clip: padding-box;

##### 4.ios 设置input 按钮样式会被默认样式覆盖

解决方式如下：

input,textarea {
border: 0;
-webkit-appearance: none;
}
设置默认样式为 none

##### 5.IOS键盘字母输入，默认首字母大写

解决方案，设置如下属性

<input type="text"autocapitalize="off"/>

##### 6.h5底部输入框被键盘遮挡问题

h5页面有个问题是，当输入框在最底部，点击软键盘后输入框会被遮挡。

解决办法：由于弹起输入法，会执行onresize 事件，根据窗口变化，将原先是固定定位的元素改为position:static;。当关闭输入法时再切换回position:absolute;。

```
var getHeight = $(document).height();
$(window).resize(function(){
 if($(document).height() < getHeight) {
  $('#footer').css('position','static');
 }else {
  $('#footer').css('position','absolute');
 }
});
```

##### 7.IOS移动端click事件300ms的延迟响应

解决方案：

1、fastclick可以解决在手机上点击事件的300ms延迟

2、zepto的touch模块，tap事件也是为了解决在click的延迟问题

3、触摸事件的响应顺序为touchstart --> touchmove --> touchend --> click,也可以通过绑定ontouchstart事件，加快对事件的响应，解决300ms延迟问题

##### 8.在ios和andriod中,audio元素和video元素在无法自动播放

应对方案：触屏即播$('html').one('touchstart',function(){audio.play()})

##### 9.CSS动画页面闪白,动画卡顿

解决方法:

```
1.尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位
2.开启硬件加速
 -webkit-transform: translate3d(0, 0, 0);
 -moz-transform: translate3d(0, 0, 0);
 -ms-transform: translate3d(0, 0, 0); 
  transform: translate3d(0, 0, 0);
```

##### 10.fixed定位缺陷

```
iOS 下，fixed定位的元素里如果有input，键盘弹起后，点击定位会上移，显示定位也会出问题
解决：不使用fixed
body {height: 100%;}
使用absolute 替代 fixed，相对于body定位
```

11.1px问题

```
1、 媒体查询利用设备像素比缩放，设置小数像素；
    .border { border: 1px solid #999 }
    @media screen and (-webkit-min-device-pixel-ratio: 2) {
        .border { border: 0.5px solid #999 }
    }
    @media screen and (-webkit-min-device-pixel-ratio: 3) {
        .border { border: 0.333333px solid #999 }
    }
2.transform: scale(0.5) 方案
div {
    height:1px;
    background:#000;
    -webkit-transform: scaleY(0.5);
    -webkit-transform-origin:0 0;
    overflow: hidden;
}

```

12.首屏白屏问题

```
减少入口文件
静态资源本地存储
图片压缩
UI框架按需加载
重复组件打包优化
SSR
GZip
```

13.轮播图提前占位

```
height:0;
font-size:0;
padding-bottom:33%
```

14.滚动条隐藏

```
在PC端隐藏html右侧默认滚动条
html {
        /*隐藏滚动条，当IE下溢出，仍然可以滚动*/
        -ms-overflow-style:none;
        /*火狐下隐藏滚动条*/
        scrollbar-width: none;
    }
  /*Chrome下隐藏滚动条，溢出可以透明滚动*/
html::-webkit-scrollbar{width:0px}
移动端隐藏滚动条
1）给滚动条的部分设置宽高为100%， overflow-y: auto;
2）设置滚动条的部分::-webkit-scrollbar{
width: 0;
display:none;
}
```







#### 11、Css3 的新属性内核

当一些 CSS3 样式语法还存在波动时，它们提供针对浏览器的前缀。现在主要流行的浏览器内核主
要有：
Trident 内核：主要代表为 IE 浏览器
Gecko 内核：主要代表为 Firefox   FF
Presto 内核：主要代表为 Opera
Webkit 内核：产要代表为 Chrome 和 Safari
而这些不同内核的浏览器，CSS3 属性（部分需要添加前缀的属性）对应需要添加不同的前缀，也将
其称之为浏览器的私有前缀，添加上私有前缀之后的 CSS3 属性可以说是对应浏览器的私有属性：
Trident 内核：前缀为-ms
Gecko 内核：前缀为-moz
Presto 内核：前缀为-o
Webkit 内核：前缀为-webkit

#### 12、window.event || event

问题：使用 window.event 无法在 FF 上运行
解决方法：
FF 的 event 只能在事件发生的现场使用，此问题暂无法解决。可以把 event 传到函数里变通
解决：
onMouseMove = "functionName(event)"
function functionName (e) {
e = e || window.event;
......
}



# 8.移动端、小程序面试题

#### 1. 移动端兼容适配

```
<meta name="viewport" content="width=device-width, initial-scale=1.0">
适配方案：
	1.rem, em, 百分比
	2.框架的栅格布局
	3.media query媒体查询
	4.手淘团队的一套flexible.js, 自动判断dpr进行整个布局视口的放缩
```

#### 2。为什么以iPhone6为标准的设计稿的尺寸是以750px宽度来设计的呢？

```
iPhone6的满屏宽度是375px，而iPhone6采用的视网膜屏的物理像素是满屏宽度的2倍，也就是dpr(设备像素比)为2, 并且设计师所用的PS设计软件分辨率和像素关系是1:1。所以为了做出的清晰的页面，设计师一般给出750px的设计图，我们再根据需求对元素的尺寸设计和压缩。
```

#### 3.移动端首屏优化

```
采用服务器渲染ssr
按需加载配合webpack分块打包, 通过entry和commonChunkPlugin
很有必要将script标签➕异步
有轮播图 最好给个默认 另外要处理图片懒加载
打包线上也要注意去掉map 文件
组件, 路由懒加载
webpack的一切配置 肯定是必须的
压缩图片 https://tinypng.com/ 建议还是用webpack的图片压缩插件
骨架屏
Loading页面
```

#### 4. 自适应和响应式布局的区别

```
1.	

自适应布局通过检测视口分辨率，来判断当前访问的设备是：pc端、平板、手机，从而请求服务层，返回不同的页面；


响应式布局通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。
2.	自适应布局需要开发多套界面，而响应式布局只需要开发一套界面就可以了。
3.	自适应对页面做的屏幕适配是在一定范围：比如pc端一般要大于1024像素，手机端要小于768像素。而响应式布局是一套页面全部适应。
4.	自适应布局如果屏幕太小会发生内容过于拥挤。而响应式布局正是为了解决这个问题而衍生出的概念，它可以自动识别屏幕宽度并做出相应调整的网页设计。
```

















#### 5.你是怎么封装微信小程序的数据请求的？

```
1、 将所有的接口放在统一的 js 文件中并导出
2、在 app.js 中创建封装请求数据的方法
3、在子页面中调用封装的方法请求数据

```

#### 6.小程序有哪些参数传值的方法？

```
1、给 HTML 元素添加 data-*属性来传递我们需要的值，然后通过 e.currentTarget.dataset 或 onload 的
param 参数获取。但 data-名称不能有大写字母和不可以存放对象
2、设置 id 的方法标识来传值通过 e.currentTarget.id 获取设置的 id 的值,然后通过设置全局对象的方式来
传递数值
3、在 navigator 中添加参传值

```

#### 7.webview 中的页面怎么跳回小程序中？

```
<web-view/>网页中可使用 JSSDK 1.3.2 提供的接口返回小程序页面。
例如：wx.miniProgram.navigateTo({url: '/path/to/page'})

```

#### 8.小程序关联微信公众号如何确定用户的唯一性？

```
使用 wx.getUserInfo 方法 withCredentials 为 true 时可获取 encryptedData，里面有 union_id。后端需要进行对称解密。

```

#### 9.小程序如何实现下拉刷新？

```
用 view 代替 scroll-view,,设置 onPullDownRefresh 函数实现。
1、在 json 文件中配置 enablePullDownRefresh 为 true(app.json 中在 window 中设置 enablePullDownRefresh,
此效果作用于全局)。
2、在 js 文件中实现 onPullDownRefresh 方法,在网络请求完成后调用 wx.stopPullDownRefresh()来结束下拉刷
新。
```

#### 10.小程序调用后台接口遇到哪些问题？

```
1、数据的大小有限制，超过范围会直接导致整个小程序崩溃，除非重启小程序；
2、小程序不可以直接渲染文章内容页这类型的 html 文本内容，若需显示要借住插件，但插件渲染会导致
页面加载变慢，所以最好在后台对文章内容的 html 进行过滤，后台直接处理批量替换 p 标签 div 标签为 view 标
签，然后其它的标签让插件来做，减轻前端的时间。

页面加载变慢，所以最好在后台对文章内容的 html 进行过滤，后台直接处理批量替换 p 标签 div 标签为 view 标
签，然后其它的标签让插件来做，减轻前端的时间。

```

#### 11.小程序的 wxss 和 css 有哪些不一样的地方？

```
1、wxss 的图片引入需使用外链地址。
2、没有 Body，样式可直接使用 import 导入。
```

#### 12.分析下微信小程序的优劣势

```
优 势：
1、无需下载，通过搜索和扫一扫就可以打开。
2、良好的用户体验：打开速度快。
3、开发成本要比 App 要低
4、安卓上可以添加到桌面，与原生 App 差不多。
5、为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程， 不能通过审查的小程序是无法发布到线上的。
劣势：
1、限制较多。页面大小不能超过 1M。不能打开超过 5 个层级的页面。
2、样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片、导航。
3、推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。
4、依托于微信，无法开发后台管理功能。
```

# 10.webpack面试题

主要主要的作用，就是说把你的所有的代码压缩、合并。vue.比如说你的vue的文件的话，进行编译，全部就是合成编辑成一个JS文件，就是你打完包之后会发现就是他文件目录的话，就是一个js，然后一个cssS，一个MG，一个JS文件，文件里面的话，然后HTML文件还是那一个，只有一个HTML文件



### 1. webpack与grunt、gulp的不同？

三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。

grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。

webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。

### 2. 与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？

同样是基于入口的打包工具还有以下几个主流的：

- webpack
- rollup
- parcel

**从应用场景上来看：**

- webpack适用于大型复杂的前端站点构建
- rollup适用于基础库的打包，如vue、react
- parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果

由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel

### 3.有哪些常见的Loader？他们是解决什么问题的？

- file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件
- url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去
- source-map-loader：加载额外的 Source Map 文件，以方便断点调试
- image-loader：加载并且压缩图片文件
- babel-loader：把 ES6 转换成 ES5
- css-loader：加载 CSS，支持模块化、压缩、文件导入等特性
- style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。
- eslint-loader：通过 ESLint 检查 JavaScript 代码

### 4.有哪些常见的Plugin？他们是解决什么问题的？

html-webpack-plugin：可以复制一个有结构的html文件，并自动引入打包输出的所有资源（JS/CSS）
clean-webpack-plugin：重新打包自动清空 dist 目录
mini-css-extract-plugin：提取 js 中的 css 成单独文件
optimize-css-assets-webpack-plugin：压缩css
uglifyjs-webpack-plugin：压缩js
commons-chunk-plugin：提取公共代码

### 5.Loader和Plugin的不同？

**不同的作用**

- **Loader**直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。
- **Plugin**直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

**不同的用法**

- **Loader**在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）
- **Plugin**在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。

### 6.如何利用webpack来优化前端性能？（提高性能和体验）

用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。

- 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css
- 利用[CDN](https://cloud.tencent.com/product/cdn?from=10680)加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径
- 删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现
- 提取公共代码。

# 12.非技术面试题收集

**1.如何讲解：项目所有角色，项目全流程，各阶段常见问题**

PM产品经理 UE UI视觉设计师 PE前端开发 RD后端开发 CRD移动端开发 QA测试人员

```
需求经理拿到需求，并确认需求，然后开组会讲解需求并分配需求，如果有难点的技术功能实现需大家商讨下如何实现。待大家都能了解需求和功能实现之后进行开发，2周一个迭代，其中包括修改上次迭代提出的bug，并更新发布最新版进行复测，待所有功能实现完毕后，经需求经理确认功能，ui确认设计稿还原度后然后经由测试组进行测试，测试通过之后进行上线部署；
需求分析--技术方案设计-- 开发--联调--测试--上线
```

**2.、请问你了解过我们公司吗？**

我查看了关于贵公司的信息，知道你们近几年发展势头在加大，根据客观环境的变化，贵公司高层有意逐步改变发展战略和竞争战略，而且准备拓展国际市场，与海外销售商合作。

**3、你最大的缺点是什么？**

我经常在一件事上死磕到底，不完成誓不罢休。（有坚持的品质）

**4、在业余时间你通常喜欢干什么？有什么兴趣爱好？**

没事的时候，我会学习茶艺、插花，因为我想了解更多、学习更多，目的就是不断提升自己。我也会经常出去旅行，感受旅行的意义，目前已经去了10多个城市。

**5、你觉得你个性上最大的优点是什么？**

沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱。我经过一到两年的培训及项目实战，加上实习工作，使我适合这份工作。

**6、你对薪资的要求？**

我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。

**7.可以独立开发吗？**

还行 ，自己能独立开发，时间排版，以及实现的功能

**8**.**使用vue做过几个项目？**

3个项目 ，两个PC端，一个移动端，能够熟练运用vue进行项目开发

**9.外派岗位接受吗**

  根据公司的需要，如果我需要外派或出差，我会毫不犹豫接受。这是我的荣幸，因为我能在不同的地方学到 更多知识、累积更多经验。 

**10.期望薪资是多少？**

   我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。

**11.说下你上家公司？**

```
公司名称【重要】
公司地址【重要】
标志建筑物
交通【重要】
项目描述
我的职责
印象深刻的事
离职原因【重要】
开发中遇到的问题，如何解决【重要】
团队人员-某一个同事   技术经理 hr
```

**12.背调需填表格**

```
公司名称
部门名称
项目名称
离职原因
薪资
工作态度
入职离职日期
我在当前公司的职务
```

# 13.项目项话术

建造师全题库——移动端 App
项目描述:
建造师全题库 App 是北京天龟教育科技有限公司旗下一款建造师真题模考刷题软件,是一款以使用 React 框架开发的学习教育类型移动端 App,其开发背景是为了服务广大的建造师考试人员,具备视频课以及直播课堂功能,还有在线搜题、模拟考试等功能。
项目职责:
1、负责选课以及课程详情页面的开发；
2、负责发现页面倒计时功能模块实现；
3、联调接口获取真实题库数据,以及题目搜索功能实现；
4、负责我的页面各部分功能模块、以及个人资料数据上传。
技术要点:
1、利用 create-react-app 进行项目基础搭建和模块化开发。
2、使用 customize-cra 修改 webpack 部分配置；
2、使用 antd-mobile 组件库实现部分功能的快速开发；
3、利用 react、react-thunk、react-redux 管理各组件之间的数据通讯；
4、利用 Hooks 更好的连接组件，复用组件逻辑。

对应B简历话术：

我在项目中主要负责的是首页模块跟发现页模块，在首页模块中我们会把用户一周的做题数据展示出来方便给用户更加直观的对自己能力水平的评估，然后就是章节练习、真题模拟、错题收集、收藏记录的几个功能。
在也封装了两个组件，一个是基于 canvas 实现的一个类似签名效果的功能，主要用于用户在做题的时候可以在屏幕上做草稿，然后还有一个就是题目纠错组件，用于就是在用户对题目解析或者是答案有疑惑时提交错误的。其次在首页模块中还放入了部分直播课跟视频课，提供给用户试听。
然后我还负责发现模块的开发，主要功能是一个倒计时计算，用户输入一个日期，计算出当前日期到考试日期的天数，还是比较简单，然后是用户能力评估功能，主要是通过出一些不同类型的题目来给用户做，通过得分来判断用户各个类型知识的能力。还有一个题目搜索功能就是把用户输入的题目关键字传给后端再把相关题目返回。
项目人员配置：
	1 个需求经理，3 个前端，4 个后端，1 个 ui，，1 个测试。
项目亮点/ 难点：
	在做题的时候，会有一个书写功能，点击之后会有一个遮罩层，可以让用户
在屏幕上打草稿，比较方便。这个需求还是比较少见的，有点类似于签名功能，
实现方法也不止一种，用 SVG 应该也可以，但是我们是基于 canvas 元素封装了
一个组件来实现。
实现的原理就是先准备一个绘图的环境，然后配置一下线条的宽度，样式，
然后通过监听画布事件来实现连贯执行绘制，核心的内容就是计算、描绘划过的
路径。Canvas 画布为我们提供了一个用来作图的平面空间，该空间的每个点都
有自己的坐标。然后我们通过一个（getBoundingClientRect）方法获得页面 Canvas元素相对视窗的位置左边和顶部的像素距离，再利用 clientX，clientY 事件属性返回当事件被触发时鼠标指针向对于页面的水平和垂直坐标，最后通过 lineTo
和 stroke 来绘制路径。
在 events 事件执行之后要移除，否则会造成一直绘制。然后在画布右上角
还有一个清除功能，能够清除已经绘制的路径，是用 Canvas 的 clearRect 方法
就可以实现清除画布区域内容。





